# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10cyBwqWL56TOumH8TsTx-9jh1mX6yVd5
"""

import random
import time
import matplotlib.pyplot as plt
from collections import deque

class Graph:
    def __init__(self, vertices):
        self.vertices = vertices
        self.adj_list = {v: [] for v in range(vertices)}

    def add_edge(self, u, v):
        self.adj_list[u].append(v)
        self.adj_list[v].append(u)

    def dfs(self, start_node):
        visited = [False] * self.vertices
        stack = [start_node]
        visited[start_node] = True

        while stack:
            v = stack.pop()
            for i in self.adj_list[v]:
                if not visited[i]:
                    stack.append(i)
                    visited[i] = True
        return visited

# Function to generate a path graph with the given number of nodes
def generate_path_graph(num_nodes):
    graph = Graph(num_nodes)

    for i in range(num_nodes - 1):
        graph.add_edge(i, i + 1)

    return graph

# Function to generate a cycle graph with the given number of nodes
def generate_cycle_graph(num_nodes):
    graph = generate_path_graph(num_nodes)
    graph.add_edge(0, num_nodes - 1)

    return graph

# Function to generate a sparse graph with the given number of nodes and edge probability
def generate_sparse_graph(num_nodes, edge_probability):
    graph = Graph(num_nodes)

    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if random.random() < edge_probability:
                graph.add_edge(i, j)

    return graph

# Function to generate a tree graph with the given number of nodes
def generate_tree_graph(num_nodes):
    graph = Graph(num_nodes)

    for i in range(1, num_nodes):
        graph.add_edge(random.randint(0, i - 1), i)

    return graph

# Function to generate a complete graph with the given number of nodes
def generate_complete_graph(num_nodes):
    graph = Graph(num_nodes)

    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            graph.add_edge(i, j)

    return graph

# Function to generate a bipartite graph with the given number of nodes in each partition
def generate_bipartite_graph(partition1_nodes, partition2_nodes):
    graph = Graph(partition1_nodes + partition2_nodes)

    for i in range(partition1_nodes):
        for j in range(partition1_nodes, partition1_nodes + partition2_nodes):
            graph.add_edge(i, j)

    return graph


# Measure execution time for DFS on graphs with different number of nodes
def measure_dfs_execution_time(graph_generator):
    nodes_list = [i for i in range(5, 1000, 200)]
    dfs_times = []

    for num_nodes in nodes_list:
        start_time = time.time()
        graph = graph_generator(num_nodes)
        start_node = random.randint(0, num_nodes - 1)
        graph.dfs(start_node)
        end_time = time.time()
        dfs_times.append(end_time - start_time)

    return nodes_list, dfs_times

# Plot the comparison between DFS execution time for different graphs
def plot_dfs_comparison():
    graph_types = [
        ("Path", generate_path_graph),
        ("Cycle", generate_cycle_graph),
        ("Sparse", lambda num_nodes: generate_sparse_graph(num_nodes, 0.1)),
        ("Tree", generate_tree_graph),
        ("Complete", generate_complete_graph),
        ("Bipartite", lambda num_nodes: generate_bipartite_graph(num_nodes // 2, num_nodes // 2)),
    ]

    plt.figure(figsize=(12, 8))

    for graph_type, generator in graph_types:
        dfs_nodes_list, dfs_times = measure_dfs_execution_time(generator)
        plt.plot(dfs_nodes_list, dfs_times, label=f'DFS ({graph_type})', marker='o')

    plt.xlabel('Number of Nodes')
    plt.ylabel('Execution Time (seconds)')
    plt.title('Comparison of DFS Execution Time for Different Graphs')
    plt.legend()
    plt.grid(True)
    plt.show()

# Main function for measuring DFS execution time
def main_dfs():
    plot_dfs_comparison()

if __name__ == "__main__":
    main_dfs()