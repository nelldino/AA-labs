# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N2XJrg1cA52QFHCGScZDlmEdNzAs4XgS
"""

import random
import networkx as nx
import matplotlib.pyplot as plt
import heapq
import time

def generate_dense_graph(num_nodes):
    graph = nx.Graph()
    for i in range(num_nodes):
        graph.add_node(i)
        for j in range(i + 1, num_nodes):
            if random.random() < 0.7:  # Randomly connect nodes with 70% probability for denser graph
                weight = random.randint(1, 10)
                graph.add_edge(i, j, weight=weight)
    return graph

def generate_sparse_graph(num_nodes):
    graph = nx.Graph()
    for i in range(num_nodes):
        graph.add_node(i)
        for j in range(i + 1, num_nodes):
            if random.random() < 0.3:  # Randomly connect nodes with 30% probability for sparse graph
                weight = random.randint(1, 10)
                graph.add_edge(i, j, weight=weight)
    return graph

def dijkstra(graph, source):
    distances = {node: float('inf') for node in graph.nodes()}
    distances[source] = 0
    predecessors = {node: None for node in graph.nodes()}
    priority_queue = [(0, source)]
    visited_order = []

    start_time = time.time()

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        if current_distance > distances[current_node]:
            continue
        visited_order.append(current_node)
        for neighbor in graph.neighbors(current_node):
            distance = current_distance + graph[current_node][neighbor]['weight']
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))

    end_time = time.time()
    execution_time = end_time - start_time

    return execution_time

# Generate execution time data for both dense and sparse graphs
num_nodes_list = list(range(10, 800, 50))  # Generate numbers of nodes from 10 to 1000
dense_execution_times = []
sparse_execution_times = []

for num_nodes in num_nodes_list:
    dense_graph = generate_dense_graph(num_nodes)
    sparse_graph = generate_sparse_graph(num_nodes)

    source = random.choice(list(dense_graph.nodes()))
    dense_time = dijkstra(dense_graph, source)

    source = random.choice(list(sparse_graph.nodes()))
    sparse_time = dijkstra(sparse_graph, source)

    dense_execution_times.append(dense_time)
    sparse_execution_times.append(sparse_time)

# Plot execution time against number of nodes
plt.figure(figsize=(10, 6))
plt.plot(num_nodes_list, dense_execution_times, label='Dense Graph', marker='o')
plt.plot(num_nodes_list, sparse_execution_times, label='Sparse Graph', marker='o')
plt.xlabel('Number of Nodes')
plt.ylabel('Execution Time (seconds)')
plt.title('Execution Time of Dijkstra\'s Algorithm')
plt.legend()
plt.grid(True)
plt.show()